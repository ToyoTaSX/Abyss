Курсовая работа по "Основы программирования на примере C#"

# Abyss
Проект по созданию игры с использованием библиотеки Monogame на платформе .Net.

# Идея игры
Шутер с видом сверху, цель игрока - любыми способами собрать все ресурсы и вернуться на точку начала игры. После каждого уровня есть магазин, где можно потратиться заработанную валюту на новое оружие или аптечки. Как только уровни кончаются, заканчивается и игра.

# Сюжет
Сюжета, как такового, в игре нет, но по задумке главный герой совершает вылазку из бункера на поверхность постапокалиптического мира, где должен собрать ресурсы. Помешать ему пытаются другие рейдеры.

# Техническая реализация
В игре есть несколько основных классов:

	GameModel
Класс является основной игровой моделью, обрабатывающей все события в игре и заставляющей обновляться игрока, противников и т.д.
По сути может работать и без интерфейса и графического вывода. В основном выполняет функцию переключения уровней.

	Level
Тут все просто, основной элемент игры, хранит в себе карту, сущности, игрока и т.д. Создание может занимать долгое время из-за не самого оптимального 
алгоритма просчета путей для противников. Но благодаря этому во время игры снижается нагрузка и FPS становится более стабильным.

	Entity
"Болванка" для создания сущностей на своей основе, например: Player, Enemy (и дочерние классы).

	View
Основной элемент интерфейса, выполняет функцию переключения меню.

	Menu
Заготовка для создания конкретных меню. В проекте есть множество дочерних классов: MainMenu, TradeMenu...

	Input
Класс для обработки ввода пользователя

	SaveLoadManager
Статический класс, который позволяет реализовать сохранение и загрузку игры. Данные сохраняются в json формате в папке appdata/Roaming/Abyss/usersaves

# Использованные алгоритмы
Для реализации искусственного интелекта противников реализованы несколько компонентов, которые можно комбинировать и получать новые виды мобов.
На данный момент это компоненты движения в сторону игрока и стрельбы по нему. Просчет кратчайшего пути до игрока достаточно ресурсозатратная операция,
поэтому я решил, что будет оптимально изначально проссчитать кратчайший путь из каждой точки карты в каждую точку карты, а затем сохранить первую точку этого маршрута в словарь для быстрого доступа. Из-за этого уровень стал дольше загружаться, но во время самой игры производительность значительно выросла, т.к. каждый моб просто берет из словаря значения, а не просчитывает путь снова. Для поиска кратчайшего пути я использовал алгоритм Дийкстры, т.к. моя карта больше всего напоминает невзвешанный граф и мне нужно найти путь до каждой точки.
	
